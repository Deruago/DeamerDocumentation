# Template: C++ Frontend

## Overview

When you compiled a DST template to C++. You can use the template using the interface the template provides. This document covers the C++ interface of templates generated by DST.

For the rest of the document we use the following main and setting templates:

### Main

```DST
#ifndef {{header_guard}}
#define {{header_guard}}

class {{class_name}}
{
private:
	{{private_member.Variable_Field}}
public:
	{{public_member.Variable_Field}}

public:
	{{class_name}}() = default;
	~{{class_name}}() = default;
};

#endif // {{header_guard}}
```

### Setting

```DST
{{file.target_language}} = <C++>
{{file.file_name}} = <HeaderFile>
{{file.namespace}} = <deamer::templates::cmake::miscel::standard>
{{file.extension}} = <h>

{{header_guard}} = @<{{project_name.Upper}}_{{class_name.Upper}}_H>@
{{default_class_name}} = @<AstNode>@
```



## Variables

### Initializing the template

When you have compiled the template, a header file is outputted. In C++ include this header file. The header file has no dependencies and contains several types. The type representing the template follows the following name convention: "{{file.file_name}}Template". To fill in variables make an object of this type:

```C++
#include "CppClassTemplate.h"
#include <memory>

int main()
{
    auto gen = std::unique_ptr<CppClassTemplate>();
    
    return 0;
}
```

### Set a variable using a string

If you want to set a value for the variable {{class_name}}. You can access the variable as follows:

```C++
#include "CppClassTemplate.h"
#include <memory>

int main()
{
    auto gen = std::unique_ptr<CppClassTemplate>();
    gen->class_name_->Set("new value");
    return 0;
}
```

### Set a variable using a variable reference

Alongside setting strings as values. You can also set variables as values. E.g. we can set the value of {{class_name}} to be the value of {{default_class_name}} as follows:

```C++
#include "CppClassTemplate.h"
#include <memory>

int main()
{
    auto gen = std::unique_ptr<CppClassTemplate>();
    gen->class_name_->Set(gen->default_class_name_);
    return 0;
}
```

### Getting the output

```C++
#include "CppClassTemplate.h"
#include <memory>
#include <iostream>

int main()
{
    auto gen = std::unique_ptr<CppClassTemplate>();
    gen->class_name_->Set("new value");
    
    // gen->GetOutput() runs the template with the current set variables
    // The output is the generated code according to your template
    std::cout << gen->GetOutput() << "\n";
    return 0;
}
```



## Specializations

Specializations are variables which have some specialized function around the core variable. Take the Lower specialization: ```{{variable.Lower}}```. The Lower specialization takes in the value of variable and makes the name lower case.

Specializations are their own variable and can be used as such.

```C++
#include "CppClassTemplate.h"
#include <memory>
#include <iostream>

int main()
{
    auto gen = std::unique_ptr<CppClassTemplate>();
    
    // Set default class name to some variable
    // Take the specialization which lowers the default class name variable
    gen->default_class_name_->Set("THIS SHOULD BE LOWER CASE");
    gen->class_name_->Set(gen->default_class_name_->lower_);
    
    std::cout << gen->GetOutput() << "\n"; // "this should be lower case"
    return 0;
}
```



As specializations function like variables it is possible to override specializations:

```C++
#include "CppClassTemplate.h"
#include <memory>
#include <iostream>

int main()
{
    auto gen = std::unique_ptr<CppClassTemplate>();
    
    // Set default class name to some variable
    // Take the specialization which lowers the default class name variable
    gen->default_class_name_->Set("THIS SHOULD BE LOWER CASE");
    gen->default_class_name_->lower_->Set("TOTALLY DIFFERENT VALUE");
    gen->class_name_->Set(gen->default_class_name_->lower_);
    
    std::cout << gen->GetOutput() << "\n"; // "totally different value");"
    return 0;
}
```

Dependent on the specialization the reserved logic can still apply.

## Variable Fields

Variable Fields are used to store multiple values. You can see variable fields as dynamic arrays.

When you used a variable with a variable field. You can interact with the field in different ways:

- Expand the variable field (appending new elements)
- Clearing the variable field (clearing the variable field)

It is important to note that expanding the variable field will copy the underlying value internally. I.e. it will remember the current state of what it is set to.

### Expanding Variable Fields

```C++
#include "CppClassTemplate.h"
#include <memory>
#include <iostream>

int main()
{
    auto gen = std::unique_ptr<CppClassTemplate>();
    gen->class_name_->Set("AstNode");
    
    gen->private_member->Set("int a;");
    gen->private_member->ExpandVariableField(); // variable field: [ "int a;" ]
    
    return 0;
}
```

In order to expand a variable field you can call the ExpandVariableField function. This function will expand the array with the value the variable currently is. In the example above the current value is "int a;". Expanding the variable field will thus copy the value "int a;" into its container.

Doing this multiple times will look as follows:

```C++
#include "CppClassTemplate.h"
#include <memory>
#include <iostream>

int main()
{
    auto gen = std::unique_ptr<CppClassTemplate>();
    gen->class_name_->Set("AstNode");
    
    gen->private_member->Set("int a;");
    gen->private_member->ExpandVariableField(); // vf: [ "int a;" ]
    
    // "char b;" is ignored as the value is replaced by "long c;"
    // As expanding the VF will copy the current value.
    // The current value is "long c;" and thus copied.
    gen->private_member->Set("char b;");
    gen->private_member->Set("long c;");
    gen->private_member->ExpandVariableField(); // vf: [ "int a;", "long c;" ]
    
    return 0;
}
```

### Clearing Variable Fields

Clearing variable fields can be done by directly accessing the specialization and running the clear function:

```C++
#include "CppClassTemplate.h"
#include <memory>
#include <iostream>

int main()
{
    auto gen = std::unique_ptr<CppClassTemplate>();
    gen->class_name_->Set("AstNode");
    
    gen->private_member->Set("int a;");
    gen->private_member->ExpandVariableField(); // vf: [ "int a;" ]
    
    gen->private_member->variable_field->clear(); // vf: [ ]
    
    return 0;
}
```

### Variable Fields and variables set to Variable Fields

Variable Fields function just like any other specialization. This means that they can function as variables. This allows you to embed variable fields inside variable fields.

## Variable interface

### Set

Is used to set the variable to either a string or to reference another variable.

```C++
#include "CppClassTemplate.h"
#include <memory>
#include <iostream>

int main()
{
    auto gen = std::unique_ptr<CppClassTemplate>();
    gen->class_name_->Set("new value"); // Reference to string
    
    gen->class_name_->Set(gen->default_class_name_); // Reference to variable
    
    std::cout << gen->GetOutput() << "\n";
    return 0;
}
```

### Clear

Used to clear the value of the variable. If the variable had some variable or string this will be emptied:

```C++
#include "CppClassTemplate.h"
#include <memory>
#include <iostream>

int main()
{
    auto gen = std::unique_ptr<CppClassTemplate>();
    gen->class_name_->Set("new value"); // Reference to string 
    
    gen->class_name_->Clear(); 
    
    std::cout << gen->GetOutput() << "\n";
    return 0;
}
```

### Add

Used to append some value to the current value of a variable:

```C++
#include "CppClassTemplate.h"
#include <memory>
#include <iostream>

int main()
{
    auto gen = std::unique_ptr<CppClassTemplate>();
    gen->class_name_->Set("new value"); // Reference to string 
    
    gen->class_name_->Add("Abc"); 
    gen->class_name_->Add(gen->default_class_name_); 
    
    std::cout << gen->GetOutput() << "\n"; // new valueAbcAstNode
    return 0;
}
```

### GetValue

This gets the current value of a variable. 

```C++
#include "CppClassTemplate.h"
#include <memory>
#include <iostream>

int main()
{
    auto gen = std::unique_ptr<CppClassTemplate>();
    gen->class_name_->Set("new value"); // Reference to string 
    
    std::cout <<  gen->class_name_->GetValue() << "\n"; // new value
    return 0;
}
```

### 